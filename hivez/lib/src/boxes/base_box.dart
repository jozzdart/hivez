part of 'boxes.dart';

/// Signature for a custom log handler used by Hivez boxes.
///
/// This typedef allows you to provide a callback function that will receive
/// log messages generated by Hivez box operations. The log handler can be
/// used to redirect logs to your application's logging system, print them
/// to the console, write them to a file, or handle them in any other way
/// you require.
///
/// The [message] parameter contains a formatted log string describing the
/// operation, error, or debug information. Log messages are typically
/// prefixed with the box name for context (e.g., `[HivezBox:myBox] ...`).
///
/// Example usage:
/// ```dart
/// void myLogger(String message) {
///   print('MyAppLog: $message');
/// }
///
/// final box = HivezBox<String, MyModel>(
///   'myBox',
///   logger: myLogger,
/// );
/// ```
///
/// If no [LogHandler] is provided, logs are only printed in debug mode
/// (i.e., when assertions are enabled).
typedef LogHandler = void Function(String message);

/// The base interface for all HivezBox types, providing a strongly-typed,
/// production-grade abstraction over Hive boxes.
///
/// This class defines the contract for all synchronous and asynchronous
/// operations supported by Hivez, including CRUD, query, and box management
/// methods. All HivezBox variants (regular, lazy, isolated, etc.) extend this
/// interface to ensure a consistent API.
///
/// Type Parameters:
///   - [K]: The type of the keys used in the box.
///   - [T]: The type of the values stored in the box.
abstract class BoxInterface<K, T> extends SharedBoxInterface<K, T> {
  NativeBox<K, T> get _nativeBox;

  /// Constructs a [BoxInterface] with the given [name] and options.
  ///
  /// Throws an [AssertionError] if [name] is empty.
  const BoxInterface(
    super.name, {
    super.encryptionCipher,
    super.crashRecovery,
    super.path,
    super.collection,
  });

  /// Ensures the box is initialized and ready for use.
  ///
  /// Opens the box if it is not already open.
  Future<void> ensureInitialized();

  /// Returns the value at the specified [index], or `null` if not found.
  Future<T?> valueAt(int index);

  @override
  bool operator ==(Object other) {
    return other is BoxInterface<K, T> &&
        other.name == name &&
        other.isIsolated == isIsolated &&
        other.isLazy == isLazy &&
        other.path == path;
  }

  @override
  int get hashCode =>
      name.hashCode ^ isIsolated.hashCode ^ isLazy.hashCode ^ path.hashCode;

  @override
  String toString() => _stringBox('BoxInterface', this);
}

extension InternalBoxInterfaceHelpers<K, T> on BoxInterface<K, T> {
  NativeBox<K, T> get nativeBox => _nativeBox;
}

String _stringBox<K, T>(String boxType, BoxInterface<K, T> box) =>
    '$boxType [$K - $T] [${box.name}] (${box.isIsolated ? 'isolated, ' : ''}${box.isLazy ? 'lazy ' : ''}pth: ${box.path}) [${box.isInitialized ? 'initialized' : 'not initialized'}, ${box.isOpen ? 'open' : 'closed'}]';

/// Base class for all HivezBox implementations, providing core logic for
/// initialization, locking, logging, and high-level box operations.
///
/// This abstract class implements [BoxInterface] and [_BoxInterfaceHelpers],
/// and is intended to be extended by concrete HivezBox types (regular, lazy,
/// isolated, etc.). It manages the lifecycle of the underlying Hive box,
/// provides thread-safe access via locks, and supports custom logging.
///
/// Type Parameters:
///   - [K]: The type of the keys used in the box.
///   - [T]: The type of the values stored in the box.
///   - [B]: The concrete type of the underlying Hive box (e.g., [Box], [LazyBox], etc.).
///
/// Features:
/// - Ensures the box is initialized before any operation.
/// - Provides thread-safe read/write operations using [Lock].
/// - Supports custom logging via [LogHandler].
/// - Implements common query, iteration, and utility methods.
/// - Handles error propagation and debug logging.
/// - Used as the foundation for all HivezBox variants.
///
/// Example:
/// ```dart
/// class MyBox extends BaseHivezBox<String, MyModel, Box<MyModel>> { ... }
/// ```
abstract class BaseHivezBox<K, T> extends BoxInterface<K, T> {
  @override
  bool get isLazy => _nativeBox.isLazy;

  @override
  final NativeBox<K, T> _nativeBox;

  @override
  bool get isIsolated => _nativeBox.isIsolated;

  @override
  bool get isOpen => _nativeBox.isOpen;

  @override
  String? get path => _nativeBox.path;

  /// Optional custom logger for box operations.
  final LogHandler? _logger;

  /// Lock for synchronizing box initialization.
  final Lock _initLock = Lock();

  /// Lock for synchronizing write operations.
  final Lock _lock = Lock();

  @override
  bool get isInitialized => _nativeBox.isInitialized;

  /// Creates a new [BaseHivezBox] instance.
  ///
  /// This constructor is used by all concrete Hivez box implementations to
  /// initialize the box with the provided configuration options.
  ///
  /// Parameters:
  /// - [name]: The unique name of the box. Must not be empty.
  /// - [encryptionCipher]: (Optional) The [HiveCipher] to use for encrypting box data.
  /// - [crashRecovery]: (Optional) Whether crash recovery is enabled for this box. Defaults to `true`.
  /// - [path]: (Optional) Custom storage path for the box. If not provided, the default Hive path is used.
  /// - [collection]: (Optional) Logical collection name for grouping boxes.
  /// - [logger]: (Optional) A [LogHandler] callback for custom logging of box operations.
  ///
  /// Throws an [AssertionError] if [name] is empty.
  BaseHivezBox(
    super.name, {
    super.encryptionCipher,
    super.crashRecovery,
    super.path,
    super.collection,
    LogHandler? logger,
    BoxType type = BoxType.regular,
  })  : _logger = logger,
        _nativeBox = NativeBoxCreator.newBox<K, T>(
          name,
          type: type,
          encryptionCipher: encryptionCipher,
          crashRecovery: crashRecovery,
          path: path,
          collection: collection,
        );

  @override
  BoxType get boxType => _nativeBox.boxType;

  @override
  Future<void> ensureInitialized() async {
    if (_nativeBox.isInitialized) return;
    _debugLog(() => 'Initializing box...');
    await _initLock.synchronized(() async {
      if (_nativeBox.isInitialized) return;
      try {
        await _nativeBox.initialize();
        _debugLog(() => 'Box initialized successfully.');
      } catch (e, st) {
        _debugLog(() => 'Error initializing box: $e\n$st');
        rethrow;
      }
    });
  }

  @protected
  void _debugLog(String Function() messageBuilder) {
    if (_logger != null) {
      _logger('[HivezBox:$name] ${messageBuilder()}');
    } else {
      assert(() {
        print('[HivezBox:$name] ${messageBuilder()}');
        return true;
      }());
    }
  }

  @override
  Future<T?> firstWhereContains(
    String query, {
    required String Function(T item) searchableText,
  }) =>
      _executeRead(() =>
          _nativeBox.firstWhereContains(query, searchableText: searchableText));

  @override
  Future<T?> firstWhereOrNull(bool Function(T item) condition) =>
      _executeRead(() => _nativeBox.firstWhereOrNull(condition));

  @override
  Future<List<T>> getValuesWhere(bool Function(T value) condition) =>
      _executeRead(() => _nativeBox.getValuesWhere(condition));

  @override
  Future<List<K>> getKeysWhere(bool Function(K key, T value) condition) =>
      _executeRead(() => _nativeBox.getKeysWhere(condition));

  @override
  Future<K?> firstKeyWhere(bool Function(K key, T value) condition) =>
      _executeRead(() => _nativeBox.firstKeyWhere(condition));

  @override
  Future<T?> firstValueWhere(bool Function(K key, T value) condition) =>
      _executeRead(() => _nativeBox.firstValueWhere(condition));

  @override
  Future<K?> searchKeyOf(T value) => firstKeyWhere((k, v) => v == value);

  @override
  Future<T?> get(K key, {T? defaultValue}) =>
      _executeRead(() => _nativeBox.get(key, defaultValue: defaultValue));

  @override
  Future<Iterable<T>> getAllValues() =>
      _executeRead(() => _nativeBox.getAllValues());

  @override
  Future<Map<K, T>> toMap() => _executeRead(() => _nativeBox.toMap());

  @override
  Future<T?> getAt(int index) => _executeRead(() => _nativeBox.getAt(index));

  @override
  Future<List<T>> getMany(Iterable<K> keys) =>
      _executeRead(() => _nativeBox.getMany(keys));

  @override
  Future<bool> moveKey(K oldKey, K newKey) =>
      _executeWrite(() => _nativeBox.moveKey(oldKey, newKey));

  Future<R> _executeWrite<R>(Future<R> Function() action) async {
    await ensureInitialized(); // <-- ensures box is ready
    return _lock.synchronized(action);
  }

  Future<R> _executeRead<R>(Future<R> Function() action) async {
    await ensureInitialized();
    return await action(); // safer if action throws
  }

  @override
  Future<void> foreachKey(Future<void> Function(K key) action,
          {bool Function()? breakCondition}) =>
      _executeRead(
          () => _nativeBox.foreachKey(action, breakCondition: breakCondition));

  @override
  Future<void> foreachValue(Future<void> Function(K key, T value) action,
          {bool Function()? breakCondition}) =>
      _executeRead(() =>
          _nativeBox.foreachValue(action, breakCondition: breakCondition));

  @override
  Future<int> estimateSizeBytes() =>
      _executeRead(() => _nativeBox.estimateSizeBytes());

  @override
  String toString() => _stringBox('BaseHivezBox', this);

  @override
  Future<void> deleteFromDisk() async {
    _debugLog(() => 'Deleting box from disk...');
    try {
      await _nativeBox.deleteFromDisk();
      _debugLog(() => 'Box deleted successfully.');
    } catch (e, st) {
      _debugLog(() => 'Error deleting box: $e\n$st');
      rethrow;
    }
  }

  @override
  Future<void> closeBox() async {
    _debugLog(() => 'Closing box...');
    try {
      await _nativeBox.closeBox();
      _debugLog(() => 'Box closed successfully.');
    } catch (e, st) {
      _debugLog(() => 'Error closing box: $e\n$st');
      rethrow;
    }
  }

  @override
  Future<void> put(K key, T value) =>
      _executeWrite(() => _nativeBox.put(key, value));

  @override
  Future<void> putAll(Map<K, T> entries) =>
      _executeWrite(() => _nativeBox.putAll(entries));

  @override
  Future<void> replaceAll(Map<K, T> entries) =>
      _executeWrite(() => _nativeBox.replaceAll(entries));

  @override
  Future<void> putAt(int index, T value) =>
      _executeWrite(() => _nativeBox.putAt(index, value));

  @override
  Future<void> delete(K key) => _executeWrite(() => _nativeBox.delete(key));

  @override
  Future<void> deleteAt(int index) =>
      _executeWrite(() => _nativeBox.deleteAt(index));

  @override
  Future<void> deleteAll(Iterable<K> keys) =>
      _executeWrite(() => _nativeBox.deleteAll(keys));

  @override
  Future<void> clear() => _executeWrite(() => _nativeBox.clear());

  @override
  Future<bool> containsKey(K key) =>
      _executeRead(() => _nativeBox.containsKey(key));

  @override
  Future<int> get length => _executeRead(() => _nativeBox.length);

  @override
  Future<Iterable<K>> getAllKeys() =>
      _executeRead(() => _nativeBox.getAllKeys());

  @override
  Future<int> add(T value) => _executeWrite(() => _nativeBox.add(value));

  @override
  Future<Iterable<int>> addAll(Iterable<T> values) =>
      _executeWrite(() => _nativeBox.addAll(values));

  @override
  Future<K?> keyAt(int index) => _executeRead(() => _nativeBox.keyAt(index));

  @override
  Future<bool> get isEmpty => _executeRead(() => _nativeBox.isEmpty);

  @override
  Future<bool> get isNotEmpty => _executeRead(() => _nativeBox.isNotEmpty);

  @override
  Future<void> flushBox() => _executeWrite(() async {
        _debugLog(() => 'Flushing box...');
        try {
          await _nativeBox.flushBox();
          _debugLog(() => 'Box flushed successfully.');
        } catch (e, st) {
          _debugLog(() => 'Error flushing box: $e\n$st');
          rethrow;
        }
      });

  @override
  Future<void> compactBox() => _executeWrite(() => _nativeBox.compactBox());

  @override
  Stream<BoxEvent> watch(K key) => _nativeBox.watch(key);

  @override
  Future<T?> valueAt(int index) => getAt(index);
}
